<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
    <div id="dial">
          <div id="instructions" onclick="enableSensor()">
            <span id="close">Ã—</span>
            <!--<strong>iOS:</strong> 
            Allow motion sensor access.<br>
            <strong>Android:</strong> Align smartphone to the north, reload page, allow motion sensor access.</div> -->
            Click to start device orientation control<br><br>
        </div>
    
		<script src="js/pixi.min.js"></script>
    <script src="js/fulltilt.min.js"></script>
		<script>
      let app = new PIXI.Application({width: window.innerWidth, height: window.innerHeight});
      let alpha;
      let beta;
      document.body.appendChild(app.view);
      
      let img = new PIXI.Sprite.from("img.jpg");
      img.width = window.innerWidth;
      img.height = window.innerHeight;
      app.stage.addChild(img);
      
      depthMap = new PIXI.Sprite.from("depthMap.jpg");
      depthMap.width = window.innerWidth;
      depthMap.height = window.innerHeight;
      app.stage.addChild(depthMap);
        
      displacementFilter = new PIXI.filters.DisplacementFilter(depthMap);
      app.stage.filters = [displacementFilter];
      
      window.onmousemove = function(e) {
        displacementFilter.scale.x = (window.innerWidth / 2 - e.clientX) /40;
        displacementFilter.scale.y = (window.innerHeight / 2 - e.clientY) /40;
        console.log(displacementFilter.scale.x + " " + displacementFilter.scale.y);
      };
      window.ontouchmove = function(e) {
        displacementFilter.scale.x = -(window.innerWidth / 2 - e.pageX) /30;
        displacementFilter.scale.y = -(window.innerHeight / 2 - e.pageY) /30;
        console.log(displacementFilter.scale.x + " " + displacementFilter.scale.y);
      };
      
      /*
      //if (window.DeviceOrientationEvent) {
         window.addEventListener("deviceorientation", (event) => {
           const rotateDegrees = event.alpha; // alpha: rotation around z-axis
           const leftToRight = event.gamma; // gamma: left to right
           const frontToBack = event.beta; // beta: front back motion
           //debugger;
           handleOrientationEvent(frontToBack, leftToRight, rotateDegrees);
         }, true);
      //}
      const handleOrientationEvent = (frontToBack, leftToRight, rotateDegrees) => {
        console.log(leftToRight + " " + rotateDegrees);
        displacementFilter.scale.x = (window.innerWidth / 2 - leftToRight) /40;
        displacementFilter.scale.y = (window.innerHeight / 2 - frontToBack) /40;
      };*/
      
      var initRotateDegrees;
      var initFrontToBack;
      var initLeftToRight;
      var speed = 0.3;
      var lastRotateDegrees;
      var lastFrontToBack;
      var lastLeftToRight;
      
      function direction() {
        
        
            var rotateDegrees = event.alpha; // alpha: rotation around z-axis
            var leftToRight = event.gamma; // gamma: left to right
            var frontToBack = event.beta; // beta: front back motion
            
            var leftToRightFlag = 0;
            var frontToBackFlag = 0;
            var rotateDegreesFlag = 0;
            
            if (initFrontToBack === undefined){
              initRotateDegrees = rotateDegrees;
              initFrontToBack = frontToBack;
              initLeftToRight = leftToRight;
            }
            
            if (initLeftToRight > leftToRight){
              leftToRightFlag = 1;
            }else{
              leftToRightFlag = -1;
            }
            if (initFrontToBack > frontToBack){
              frontToBackFlag = 1;
            }else{
              frontToBackFlag = -1;
            }
            if (initRotateDegrees > rotateDegrees){
              rotateDegreesFlag = 1;
            }else{
              rotateDegreesFlag = -1;
            }
            
            if (Math.abs(displacementFilter.scale.x) < 15){
              displacementFilter.scale.x = displacementFilter.scale.x + Math.sin(leftToRight);
            }
            if (Math.abs(displacementFilter.scale.y) < 15){
              displacementFilter.scale.y = displacementFilter.scale.y + Math.sin(frontToBack);
            }
            //displacementFilter.scale.x = displacementFilter.scale.x + Math.sin(leftToRight);
            //displacementFilter.scale.y = displacementFilter.scale.y + Math.sin(frontToBack);
            console.log(rotateDegreesFlag + " " + leftToRightFlag +" " + frontToBackFlag);
            
            lastLeftToRight = leftToRight;
            lastFrontToBack = frontToBack;
            lastRotateDegrees = rotateDegrees;
      }
      var mobileDevice = false;
      try {
        DeviceMotionEvent;
        mobileDevice = true;
      }catch{
        console.log("DeviceMotionEvent is not defined");
      }
          
      function enableSensor(){
        if (mobileDevice && typeof DeviceMotionEvent.requestPermission==="function") { // iOS 13+ devices
            DeviceMotionEvent.requestPermission()
              .then((state)=>{
                if (state==="granted") {
                  window.addEventListener("deviceorientation", direction);
                  compassOn=true;
                } else {
                  console.error("Motion sensor access denied.");}})
              .catch(console.error);
          } else { // non iOS 13+ devices
            window.addEventListener("deviceorientation", direction);
          }
      }    
      
		</script>
	</body>
</html>